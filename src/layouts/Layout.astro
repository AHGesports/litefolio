---
import { SEO } from "astro-seo";
import { SITE } from "../consts";
import SpeedInsights from "@vercel/speed-insights/astro";
import Analytics from "@vercel/analytics/astro";

interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en" class="scroll-smooth">
  <head>
    <SEO
      title={`${SITE.TITLE} - Portfolio`}
      description={SITE.DESCRIPTION}
      openGraph={{
        basic: {
          title: `${SITE.TITLE} - Portfolio`,
          type: "website",
          image: "/assets/preview.png",
        },
      }}
    />
    <meta charset="UTF-8" />
    <meta
      name="description"
      content={SITE.DESCRIPTION}
    />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <!-- Preload critical fonts for faster FCP/LCP -->
    <link rel="preload" href="/fonts/IBMPlexMono-Bold-latin.woff2" as="font" type="font/woff2" crossorigin fetchpriority="high" />
    <link rel="preload" href="/fonts/GeistVF.woff" as="font" type="font/woff" crossorigin fetchpriority="high" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>

    <!-- OverlayScrollbars CSS -->
    <link rel="stylesheet" href="/vendor/overlayscrollbars.min.css" />
  </head>
  <body
    class="relative flex flex-col w-full min-h-dvh bg-background"
  >
    <!-- Custom Cursor (DISABLED)
    <div id="cursor" class="cursor" aria-hidden="true"></div>
    -->

    <slot />


    <!-- Cursor Script (DISABLED)
    <script>
      const cursorEl = document.getElementById('cursor');
      if (cursorEl) {
        const cursor = cursorEl;
        let mouseX = 0, mouseY = 0;
        let cursorX = 0, cursorY = 0;
        let currentScale = 1, targetScale = 1;
        let isVisible = false;
        let isFirstMove = true;
        let animationId: number | null = null;
        let forceLowPerf = false; // For testing
        let isIdle = false;
        let idleTimeoutId: number | null = null;

        // Scale values for hover states
        const SCALE_DEFAULT = 1;
        const SCALE_HOVERING = 2.125;      // 68px / 32px
        const SCALE_HOVERING_MEDIA = 2.8125; // 90px / 32px

        // Respect reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // Check URL params for testing mode: ?cursor=lowperf or ?cursor=highperf
        const urlParams = new URLSearchParams(window.location.search);
        const cursorMode = urlParams.get('cursor');

        // Detect low-performance devices for fallback styling
        const detectLowPerformance = () => {
          // URL override for testing
          if (cursorMode === 'lowperf') return true;
          if (cursorMode === 'highperf') return false;
          if (forceLowPerf) return true;

          const lowCores = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2;
          const lowMemory = (navigator as any).deviceMemory && (navigator as any).deviceMemory <= 2;
          const chromeMatch = /Chrome\/(\d+)/.exec(navigator.userAgent);
          const chromeVersion = chromeMatch ? parseInt(chromeMatch[1]) : 999;
          const oldChrome = chromeVersion < 90;
          return lowCores || lowMemory || oldChrome;
        };

        let isLowPerformance = detectLowPerformance();

        // Cached easing factor - set at initialization, updated when perf mode changes
        let easingFactor = isLowPerformance ? 0.25 : 0.15;

        // Apply low-performance class if needed
        const applyPerfMode = (lowPerf: boolean) => {
          if (lowPerf) {
            cursor.classList.add('low-performance');
          } else {
            cursor.classList.remove('low-performance');
          }
          isLowPerformance = lowPerf;
          easingFactor = lowPerf ? 0.25 : 0.15;
        };

        applyPerfMode(isLowPerformance);

        // Idle state management for will-change optimization
        function setIdle() {
          if (!isIdle) {
            isIdle = true;
            cursor.style.willChange = 'auto';
          }
        }

        function clearIdle() {
          if (idleTimeoutId) {
            clearTimeout(idleTimeoutId);
            idleTimeoutId = null;
          }
          if (isIdle) {
            isIdle = false;
            cursor.style.willChange = 'transform';
          }
        }

        // Show cursor on first mouse move
        // PERF: Passive listener improves input latency by 1-2ms
        document.addEventListener('mousemove', (e) => {
          mouseX = e.clientX;
          mouseY = e.clientY;

          // Clear idle state when mouse moves
          clearIdle();

          // Fix: Set initial position on first move (prevents jump from 0,0)
          if (isFirstMove) {
            cursorX = mouseX;
            cursorY = mouseY;
            updateTransform();
            isFirstMove = false;
          }

          if (!isVisible) {
            cursor.style.opacity = '1';
            isVisible = true;
          }

          // Start animation if not running
          if (!animationId) {
            animate();
          }
        }, { passive: true });

        // Hide cursor when mouse leaves window
        document.addEventListener('mouseleave', () => {
          cursor.style.opacity = '0';
          isVisible = false;
        });

        // Update transform with both position and scale (GPU-only, no layout)
        function updateTransform() {
          cursor.style.transform = `translate3d(${cursorX - 16}px, ${cursorY - 16}px, 0) scale(${currentScale})`;
        }

        // Animation loop - interpolates both position AND scale
        function animate() {
          const dx = mouseX - cursorX;
          const dy = mouseY - cursorY;
          const ds = targetScale - currentScale;

          // Use cached easing factor (faster on low-perf devices)
          cursorX += dx * easingFactor;
          cursorY += dy * easingFactor;
          currentScale += ds * easingFactor;

          updateTransform();

          // Stop when cursor catches up (position within 0.5px, scale within 0.01)
          if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5 && Math.abs(ds) < 0.01) {
            animationId = null;
            // Schedule idle state after 100ms of inactivity
            idleTimeoutId = window.setTimeout(setIdle, 100);
            return;
          }

          animationId = requestAnimationFrame(animate);
        }

        // Helper to set cursor state and target scale
        function setCursorState(state: 'default' | 'hovering' | 'hovering-media') {
          cursor.classList.remove('hovering', 'hovering-media');

          // Skip scale animation if user prefers reduced motion
          if (prefersReducedMotion) {
            if (state !== 'default') cursor.classList.add(state);
            return;
          }

          switch (state) {
            case 'hovering':
              cursor.classList.add('hovering');
              targetScale = SCALE_HOVERING;
              break;
            case 'hovering-media':
              cursor.classList.add('hovering-media');
              targetScale = SCALE_HOVERING_MEDIA;
              break;
            default:
              targetScale = SCALE_DEFAULT;
          }

          // Restart animation for scale interpolation
          if (!animationId) {
            animate();
          }
        }

        // Event delegation for hover states - O(2) listeners instead of O(n)
        function isInteractiveElement(el: Element): boolean {
          if (el.hasAttribute('data-cursor') && el.getAttribute('data-cursor') === 'none') return false;
          if (el.closest('nav')) return false;
          return el.matches('a, button, [role="button"]');
        }

        function isMediaElement(el: Element): boolean {
          return el.matches('video, [data-cursor="media"]');
        }

        // PERF: Passive listener improves input latency
        document.addEventListener('mouseover', (e) => {
          const target = e.target as Element;
          if (!target) return;

          // Check if target or ancestor is a media element
          const mediaEl = target.closest('video, [data-cursor="media"]');
          if (mediaEl) {
            setCursorState('hovering-media');
            return;
          }

          // Check if target or ancestor is interactive (but not in nav, not data-cursor="none")
          const interactiveEl = target.closest('a, button, [role="button"]');
          if (interactiveEl && isInteractiveElement(interactiveEl)) {
            setCursorState('hovering');
          }
        }, { passive: true });

        // PERF: Passive listener improves input latency
        document.addEventListener('mouseout', (e) => {
          const target = e.target as Element;
          const relatedTarget = (e as MouseEvent).relatedTarget as Element | null;
          if (!target) return;

          // Check if leaving a media element
          const mediaEl = target.closest('video, [data-cursor="media"]');
          if (mediaEl) {
            // Only reset if not moving to another media element
            if (!relatedTarget || !relatedTarget.closest('video, [data-cursor="media"]')) {
              setCursorState('default');
            }
            return;
          }

          // Check if leaving an interactive element
          const interactiveEl = target.closest('a, button, [role="button"]');
          if (interactiveEl && isInteractiveElement(interactiveEl)) {
            // Only reset if not moving to another interactive element
            if (!relatedTarget || !relatedTarget.closest('a, button, [role="button"]') ||
                (relatedTarget.closest('a, button, [role="button"]') && !isInteractiveElement(relatedTarget.closest('a, button, [role="button"]')!))) {
              setCursorState('default');
            }
          }
        }, { passive: true });

        // Hide on touch devices
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
          cursor.style.display = 'none';
        }

        // Page Visibility API - pause animation when tab is hidden
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            // Cancel animation and idle timeout when tab is hidden
            if (animationId) {
              cancelAnimationFrame(animationId);
              animationId = null;
            }
            if (idleTimeoutId) {
              clearTimeout(idleTimeoutId);
              idleTimeoutId = null;
            }
            setIdle();
          }
          // Animation restarts automatically on next mousemove when visible
        });

        // Expose testing API globally
        (window as any).cursorDebug = {
          // Toggle low-performance mode
          setLowPerf: (enabled: boolean) => {
            forceLowPerf = enabled;
            applyPerfMode(enabled);
            console.log(`Cursor: ${enabled ? 'LOW' : 'HIGH'} performance mode`);
          },
          // Get current state
          getState: () => ({
            isLowPerformance,
            forceLowPerf,
            isIdle,
            isAnimating: animationId !== null,
            currentScale,
            targetScale,
            position: { x: cursorX, y: cursorY },
            mouse: { x: mouseX, y: mouseY },
            classes: Array.from(cursor.classList),
            computedStyles: {
              backdropFilter: getComputedStyle(cursor).backdropFilter,
              transform: getComputedStyle(cursor).transform,
              contain: getComputedStyle(cursor).contain,
              willChange: getComputedStyle(cursor).willChange,
            }
          }),
          // Device detection info
          getDeviceInfo: () => ({
            cores: navigator.hardwareConcurrency,
            memory: (navigator as any).deviceMemory,
            userAgent: navigator.userAgent,
            detectedLowPerf: detectLowPerformance(),
          }),
          // Help
          help: () => {
            console.log(`
╔════════════════════════════════════════════════════════════╗
║                  CURSOR DEBUG API                          ║
╠════════════════════════════════════════════════════════════╣
║ cursorDebug.setLowPerf(true)   - Enable low-perf mode      ║
║ cursorDebug.setLowPerf(false)  - Enable high-perf mode     ║
║ cursorDebug.getState()         - Get cursor state + idle   ║
║ cursorDebug.getDeviceInfo()    - Get device capabilities   ║
╠════════════════════════════════════════════════════════════╣
║ URL Parameters:                                            ║
║   ?cursor=lowperf   - Force low-performance mode           ║
║   ?cursor=highperf  - Force high-performance mode          ║
╠════════════════════════════════════════════════════════════╣
║ Idle State:                                                ║
║   will-change removed after 100ms idle (saves GPU memory)  ║
║   Animation pauses when tab is hidden (Page Visibility API)║
╚════════════════════════════════════════════════════════════╝
            `);
          }
        };

        // Log help hint on load
        if (cursorMode) {
          console.log(`Cursor: Forced ${cursorMode} mode via URL parameter`);
        }
      }
    </script>
    -->

    <!-- OverlayScrollbars -->
    <script is:inline src="/vendor/overlayscrollbars.min.js"></script>
    <script is:inline>
      var OS = OverlayScrollbarsGlobal.OverlayScrollbars;
      // Initialize on body
      OS(document.body, {});
      // Initialize on modal content areas
      document.querySelectorAll('#skills-modal-content, #contact-modal .overflow-y-auto').forEach(function(el) {
        OS(el, {});
      });

      // Consolidated scroll handler with RAF throttling
      // Handles both scrollbar color and header dark mode detection
      (function() {
        var darkSections = document.querySelectorAll('#projects, #contact');
        var header = document.getElementById('main-header');
        var viewportHeight = window.innerHeight;
        var sectionBounds = []; // Cached section bounds
        var headerHeight = 0; // PERF: Cached header height (avoid getBoundingClientRect on scroll)
        var scrollTicking = false;

        // Cache section bounds and header height (recalculate on resize only)
        function cacheSectionBounds() {
          var scrollY = window.scrollY;
          sectionBounds = [];
          darkSections.forEach(function(section) {
            var rect = section.getBoundingClientRect();
            sectionBounds.push({
              top: scrollY + rect.top,
              bottom: scrollY + rect.top + rect.height
            });
          });
          // PERF: Cache header height (fixed header, dimensions only change on resize)
          if (header) {
            headerHeight = header.offsetHeight;
          }
        }

        function handleScroll() {
          var scrollY = window.scrollY;
          var viewportMiddle = scrollY + viewportHeight / 2;
          var isScrollbarOverDark = false;

          // Check scrollbar position (viewport middle)
          for (var i = 0; i < sectionBounds.length; i++) {
            if (viewportMiddle >= sectionBounds[i].top && viewportMiddle <= sectionBounds[i].bottom) {
              isScrollbarOverDark = true;
              break;
            }
          }

          // Update scrollbar color
          if (isScrollbarOverDark) {
            document.body.classList.add('scrollbar-dark-bg');
          } else {
            document.body.classList.remove('scrollbar-dark-bg');
          }

          // Check header position using cached height (NO getBoundingClientRect!)
          if (header && headerHeight) {
            // Fixed header: top is always 0, use cached height
            var headerMiddle = headerHeight / 2;
            var headerY = scrollY + headerMiddle;
            var isHeaderOverDark = false;

            for (var j = 0; j < sectionBounds.length; j++) {
              if (headerY >= sectionBounds[j].top && headerY <= sectionBounds[j].bottom) {
                isHeaderOverDark = true;
                break;
              }
            }

            if (isHeaderOverDark) {
              header.classList.add('header-dark-bg');
            } else {
              header.classList.remove('header-dark-bg');
            }
          }

          scrollTicking = false;
        }

        function onScroll() {
          if (!scrollTicking) {
            scrollTicking = true;
            requestAnimationFrame(handleScroll);
          }
        }

        function onResize() {
          viewportHeight = window.innerHeight;
          cacheSectionBounds();
        }

        window.addEventListener('scroll', onScroll, { passive: true });
        window.addEventListener('resize', onResize, { passive: true });

        // Initial setup
        cacheSectionBounds();
        handleScroll();
      })();
    </script>

    <!-- Cal.com Embed (deferred) -->
    <script is:inline>
      // Load Cal.com after page is interactive
      if (document.readyState === 'complete') {
        initCal();
      } else {
        window.addEventListener('load', initCal);
      }
      function initCal() {
        (function (C, A, L) {
          let p = function (a, ar) { a.q.push(ar); };
          let d = C.document;
          C.Cal = C.Cal || function () {
            let cal = C.Cal;
            let ar = arguments;
            if (!cal.loaded) {
              cal.ns = {}; cal.q = cal.q || [];
              d.head.appendChild(d.createElement("script")).src = A;
              cal.loaded = true;
            }
            if (ar[0] === L) {
              const api = function () { p(api, arguments); };
              const namespace = ar[1];
              api.q = api.q || [];
              if (typeof namespace === "string") {
                cal.ns[namespace] = api;
                p(api, ar);
              } else {
                p(cal, ar);
              }
              return;
            }
            p(cal, ar);
          };
        })(window, "https://app.cal.com/embed/embed.js", "init");
        Cal("init", { origin: "https://cal.com" });
        Cal("ui", {"styles":{"branding":{"brandColor":"#000000"}},"hideEventTypeDetails":false,"layout":"month_view"});
      }
    </script>

    <!-- Analytics (end of body for better FCP) -->
    <Analytics />
    <SpeedInsights />
  </body>
</html>

<style is:global>
  @tailwind base;
  @tailwind components;
  @tailwind utilities;

  @layer base {
    :root {
      --primary: 252, 100%, 64%;
      --secondary: 254, 100%, 73%;
      --background: 0, 0%, 100%;
      --foreground: 0, 0%, 9%;
      --card: 0, 0%, 98%;
      --dark-card: 0, 0%, 7%;
      --muted: 0, 0%, 92%;
      --muted-foreground: 0, 0%, 40%;
      --accent: 0, 0%, 92%;
      --border: 220 13% 91%;
      --dark-border: 0, 0%, 11%;
    }
  }

  @layer base {
    /* Self-hosted fonts for faster FCP/LCP (no external CSS blocking) */
    @font-face {
      font-family: "IBM Plex Mono";
      src: url("/fonts/IBMPlexMono-Bold-latin.woff2") format("woff2");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "Geist";
      src: url("/fonts/GeistVF.woff") format("woff");
      font-display: swap;
    }
    * {
      @apply border-border;
    }
    html {
      scroll-padding-top: 6rem;
    }
    body {
      font-family: "Geist", system-ui, sans-serif;
      @apply bg-background text-foreground;
    }
  }

  /* Hide native scrollbars */
  html, body {
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  html::-webkit-scrollbar,
  body::-webkit-scrollbar {
    display: none;
  }

  .perfect-shadow {
    box-shadow: var(--perfect-shadow);
    --base: hsl(214 80% 27% / 4%);
    --shade: hsl(from var(--base) calc(h + 8) 25 calc(l - 5));
    --perfect-shadow: 0 0 0 1px var(--base), 0 1px 1px -0.5px var(--shade),
      0 3px 3px -1.5px var(--shade), 0 6px 6px -3px var(--shade),
      0 12px 12px -6px var(--base), 0 24px 24px -12px var(--base);
  }
  .font-plex {
    font-family: "IBM Plex Mono", monospace;
  }

  /* Custom Cursor Styles (DISABLED)
  @media (hover: hover) and (pointer: fine) {
    * {
      cursor: none !important;
    }
  }

  .cursor {
    position: fixed;
    top: 0;
    left: 0;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9999;
    opacity: 0;

    transition: opacity 0.2s ease;

    backface-visibility: hidden;
    transform-origin: center center;

    contain: layout style paint size;
    isolation: isolate;

    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);

    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.12) 0%,
      rgba(0, 0, 0, 0.03) 100%
    );
    border: 1px solid rgba(128, 128, 128, 0.3);

    box-shadow:
      0 2px 12px rgba(0, 0, 0, 0.12),
      inset 0 1px 1px rgba(255, 255, 255, 0.25);
  }

  @supports not (backdrop-filter: blur(1px)) {
    .cursor {
      background: rgba(200, 200, 200, 0.35);
    }
  }

  .cursor.low-performance {
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
    background: rgba(180, 180, 180, 0.25);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    transition: opacity 0.15s ease;
  }

  .cursor.hovering {
    backdrop-filter: blur(2px);
    -webkit-backdrop-filter: blur(2px);
  }

  .cursor.low-performance.hovering {
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
    background: rgba(180, 180, 180, 0.2);
  }

  .cursor.hovering-media {
    backdrop-filter: blur(1.5px);
    -webkit-backdrop-filter: blur(1.5px);
  }

  .cursor.low-performance.hovering-media {
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
    background: rgba(180, 180, 180, 0.18);
  }

  @media (hover: none), (pointer: coarse) {
    .cursor {
      display: none !important;
    }
    * {
      cursor: auto !important;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .cursor {
      transition: opacity 0.2s ease;
    }
  }
  */
</style>
